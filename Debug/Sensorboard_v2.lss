
Sensorboard_v2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000570  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000019  00800060  00800060  000005e4  2**0
                  ALLOC
  2 .comment      00000030  00000000  00000000  000005e4  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 00000088  00000000  00000000  00000614  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000008b9  00000000  00000000  0000069c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000391  00000000  00000000  00000f55  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000431  00000000  00000000  000012e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000190  00000000  00000000  00001718  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    000003d3  00000000  00000000  000018a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000032e  00000000  00000000  00001c7b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000068  00000000  00000000  00001fa9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	1f c0       	rjmp	.+62     	; 0x42 <__bad_interrupt>
   4:	1e c0       	rjmp	.+60     	; 0x42 <__bad_interrupt>
   6:	1d c0       	rjmp	.+58     	; 0x42 <__bad_interrupt>
   8:	1c c0       	rjmp	.+56     	; 0x42 <__bad_interrupt>
   a:	1b c0       	rjmp	.+54     	; 0x42 <__bad_interrupt>
   c:	1a c0       	rjmp	.+52     	; 0x42 <__bad_interrupt>
   e:	c3 c1       	rjmp	.+902    	; 0x396 <__vector_7>
  10:	05 c2       	rjmp	.+1034   	; 0x41c <__vector_8>
  12:	17 c0       	rjmp	.+46     	; 0x42 <__bad_interrupt>
  14:	16 c0       	rjmp	.+44     	; 0x42 <__bad_interrupt>
  16:	15 c0       	rjmp	.+42     	; 0x42 <__bad_interrupt>
  18:	14 c0       	rjmp	.+40     	; 0x42 <__bad_interrupt>
  1a:	13 c0       	rjmp	.+38     	; 0x42 <__bad_interrupt>
  1c:	12 c0       	rjmp	.+36     	; 0x42 <__bad_interrupt>
  1e:	11 c0       	rjmp	.+34     	; 0x42 <__bad_interrupt>
  20:	10 c0       	rjmp	.+32     	; 0x42 <__bad_interrupt>
  22:	0f c0       	rjmp	.+30     	; 0x42 <__bad_interrupt>
  24:	0e c0       	rjmp	.+28     	; 0x42 <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf ed       	ldi	r28, 0xDF	; 223
  2c:	cd bf       	out	0x3d, r28	; 61

0000002e <__do_clear_bss>:
  2e:	20 e0       	ldi	r18, 0x00	; 0
  30:	a0 e6       	ldi	r26, 0x60	; 96
  32:	b0 e0       	ldi	r27, 0x00	; 0
  34:	01 c0       	rjmp	.+2      	; 0x38 <.do_clear_bss_start>

00000036 <.do_clear_bss_loop>:
  36:	1d 92       	st	X+, r1

00000038 <.do_clear_bss_start>:
  38:	a9 37       	cpi	r26, 0x79	; 121
  3a:	b2 07       	cpc	r27, r18
  3c:	e1 f7       	brne	.-8      	; 0x36 <.do_clear_bss_loop>
  3e:	4f d1       	rcall	.+670    	; 0x2de <main>
  40:	95 c2       	rjmp	.+1322   	; 0x56c <_exit>

00000042 <__bad_interrupt>:
  42:	de cf       	rjmp	.-68     	; 0x0 <__vectors>

00000044 <sensor_start>:
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
  44:	08 b6       	in	r0, 0x38	; 56
  46:	04 fe       	sbrs	r0, 4
  48:	fd cf       	rjmp	.-6      	; 0x44 <sensor_start>
	TIFR |= (1<<OCF0A);
  4a:	98 b7       	in	r25, 0x38	; 56
  4c:	90 61       	ori	r25, 0x10	; 16
  4e:	98 bf       	out	0x38, r25	; 56
}

static void sensor_start(uint8_t read) { //TODO: optimize...
	i2c_wait();
	DDRA |= 0xDC;
  50:	9a b3       	in	r25, 0x1a	; 26
  52:	9c 6d       	ori	r25, 0xDC	; 220
  54:	9a bb       	out	0x1a, r25	; 26
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
  56:	08 b6       	in	r0, 0x38	; 56
  58:	04 fe       	sbrs	r0, 4
  5a:	fd cf       	rjmp	.-6      	; 0x56 <sensor_start+0x12>
	TIFR |= (1<<OCF0A);
  5c:	98 b7       	in	r25, 0x38	; 56
  5e:	90 61       	ori	r25, 0x10	; 16
  60:	98 bf       	out	0x38, r25	; 56

static void sensor_start(uint8_t read) { //TODO: optimize...
	i2c_wait();
	DDRA |= 0xDC;
	i2c_wait();
	DDRA |= (1<<PA1);
  62:	d1 9a       	sbi	0x1a, 1	; 26
	
	uint8_t adress = 0x52 + (read&1);
  64:	48 2f       	mov	r20, r24
  66:	41 70       	andi	r20, 0x01	; 1
  68:	4e 5a       	subi	r20, 0xAE	; 174
  6a:	20 e0       	ldi	r18, 0x00	; 0
  6c:	30 e0       	ldi	r19, 0x00	; 0
	for(uint8_t i = 0; i < 8; i++) {
		if((adress<<i)&0x80) DDRA &= ~0xDC;
  6e:	50 e0       	ldi	r21, 0x00	; 0
  70:	ca 01       	movw	r24, r20
  72:	02 2e       	mov	r0, r18
  74:	02 c0       	rjmp	.+4      	; 0x7a <sensor_start+0x36>
  76:	88 0f       	add	r24, r24
  78:	99 1f       	adc	r25, r25
  7a:	0a 94       	dec	r0
  7c:	e2 f7       	brpl	.-8      	; 0x76 <sensor_start+0x32>
  7e:	87 ff       	sbrs	r24, 7
  80:	04 c0       	rjmp	.+8      	; 0x8a <sensor_start+0x46>
  82:	8a b3       	in	r24, 0x1a	; 26
  84:	83 72       	andi	r24, 0x23	; 35
  86:	8a bb       	out	0x1a, r24	; 26
  88:	03 c0       	rjmp	.+6      	; 0x90 <sensor_start+0x4c>
		else DDRA |= 0xDC;
  8a:	8a b3       	in	r24, 0x1a	; 26
  8c:	8c 6d       	ori	r24, 0xDC	; 220
  8e:	8a bb       	out	0x1a, r24	; 26
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
  90:	08 b6       	in	r0, 0x38	; 56
  92:	04 fe       	sbrs	r0, 4
  94:	fd cf       	rjmp	.-6      	; 0x90 <sensor_start+0x4c>
	TIFR |= (1<<OCF0A);
  96:	88 b7       	in	r24, 0x38	; 56
  98:	80 61       	ori	r24, 0x10	; 16
  9a:	88 bf       	out	0x38, r24	; 56
	uint8_t adress = 0x52 + (read&1);
	for(uint8_t i = 0; i < 8; i++) {
		if((adress<<i)&0x80) DDRA &= ~0xDC;
		else DDRA |= 0xDC;
		i2c_wait();
		DDRA &= ~(1<<PA1);
  9c:	d1 98       	cbi	0x1a, 1	; 26
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
  9e:	08 b6       	in	r0, 0x38	; 56
  a0:	04 fe       	sbrs	r0, 4
  a2:	fd cf       	rjmp	.-6      	; 0x9e <sensor_start+0x5a>
	TIFR |= (1<<OCF0A);
  a4:	88 b7       	in	r24, 0x38	; 56
  a6:	80 61       	ori	r24, 0x10	; 16
  a8:	88 bf       	out	0x38, r24	; 56
		if((adress<<i)&0x80) DDRA &= ~0xDC;
		else DDRA |= 0xDC;
		i2c_wait();
		DDRA &= ~(1<<PA1);
		i2c_wait();
		DDRA |= (1<<PA1);
  aa:	d1 9a       	sbi	0x1a, 1	; 26
  ac:	2f 5f       	subi	r18, 0xFF	; 255
  ae:	3f 4f       	sbci	r19, 0xFF	; 255
	DDRA |= 0xDC;
	i2c_wait();
	DDRA |= (1<<PA1);
	
	uint8_t adress = 0x52 + (read&1);
	for(uint8_t i = 0; i < 8; i++) {
  b0:	28 30       	cpi	r18, 0x08	; 8
  b2:	31 05       	cpc	r19, r1
  b4:	e9 f6       	brne	.-70     	; 0x70 <sensor_start+0x2c>
		i2c_wait();
		DDRA &= ~(1<<PA1);
		i2c_wait();
		DDRA |= (1<<PA1);
	}
	DDRA &= ~0xDC;
  b6:	8a b3       	in	r24, 0x1a	; 26
  b8:	83 72       	andi	r24, 0x23	; 35
  ba:	8a bb       	out	0x1a, r24	; 26
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
  bc:	08 b6       	in	r0, 0x38	; 56
  be:	04 fe       	sbrs	r0, 4
  c0:	fd cf       	rjmp	.-6      	; 0xbc <sensor_start+0x78>
	TIFR |= (1<<OCF0A);
  c2:	88 b7       	in	r24, 0x38	; 56
  c4:	80 61       	ori	r24, 0x10	; 16
  c6:	88 bf       	out	0x38, r24	; 56
		i2c_wait();
		DDRA |= (1<<PA1);
	}
	DDRA &= ~0xDC;
	i2c_wait();
	DDRA &= ~(1<<PA1);
  c8:	d1 98       	cbi	0x1a, 1	; 26
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
  ca:	08 b6       	in	r0, 0x38	; 56
  cc:	04 fe       	sbrs	r0, 4
  ce:	fd cf       	rjmp	.-6      	; 0xca <sensor_start+0x86>
	TIFR |= (1<<OCF0A);
  d0:	88 b7       	in	r24, 0x38	; 56
  d2:	80 61       	ori	r24, 0x10	; 16
  d4:	88 bf       	out	0x38, r24	; 56
	}
	DDRA &= ~0xDC;
	i2c_wait();
	DDRA &= ~(1<<PA1);
	i2c_wait();
	DDRA |= (1<<PA1);
  d6:	d1 9a       	sbi	0x1a, 1	; 26
  d8:	08 95       	ret

000000da <sensor_write>:
}

static void sensor_write(uint8_t data) { //TODO: optimize...
  da:	20 e0       	ldi	r18, 0x00	; 0
  dc:	30 e0       	ldi	r19, 0x00	; 0
	for(uint8_t i = 0; i < 8; i++) {
		if((data<<i)&0x80) DDRA &= ~0xDC;
  de:	48 2f       	mov	r20, r24
  e0:	50 e0       	ldi	r21, 0x00	; 0
  e2:	ca 01       	movw	r24, r20
  e4:	02 2e       	mov	r0, r18
  e6:	02 c0       	rjmp	.+4      	; 0xec <__stack+0xd>
  e8:	88 0f       	add	r24, r24
  ea:	99 1f       	adc	r25, r25
  ec:	0a 94       	dec	r0
  ee:	e2 f7       	brpl	.-8      	; 0xe8 <__stack+0x9>
  f0:	87 ff       	sbrs	r24, 7
  f2:	04 c0       	rjmp	.+8      	; 0xfc <__stack+0x1d>
  f4:	8a b3       	in	r24, 0x1a	; 26
  f6:	83 72       	andi	r24, 0x23	; 35
  f8:	8a bb       	out	0x1a, r24	; 26
  fa:	03 c0       	rjmp	.+6      	; 0x102 <__stack+0x23>
		else DDRA |= 0xDC;
  fc:	8a b3       	in	r24, 0x1a	; 26
  fe:	8c 6d       	ori	r24, 0xDC	; 220
 100:	8a bb       	out	0x1a, r24	; 26
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
 102:	08 b6       	in	r0, 0x38	; 56
 104:	04 fe       	sbrs	r0, 4
 106:	fd cf       	rjmp	.-6      	; 0x102 <__stack+0x23>
	TIFR |= (1<<OCF0A);
 108:	88 b7       	in	r24, 0x38	; 56
 10a:	80 61       	ori	r24, 0x10	; 16
 10c:	88 bf       	out	0x38, r24	; 56
static void sensor_write(uint8_t data) { //TODO: optimize...
	for(uint8_t i = 0; i < 8; i++) {
		if((data<<i)&0x80) DDRA &= ~0xDC;
		else DDRA |= 0xDC;
		i2c_wait();
		DDRA &= ~(1<<PA1);
 10e:	d1 98       	cbi	0x1a, 1	; 26
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
 110:	08 b6       	in	r0, 0x38	; 56
 112:	04 fe       	sbrs	r0, 4
 114:	fd cf       	rjmp	.-6      	; 0x110 <__stack+0x31>
	TIFR |= (1<<OCF0A);
 116:	88 b7       	in	r24, 0x38	; 56
 118:	80 61       	ori	r24, 0x10	; 16
 11a:	88 bf       	out	0x38, r24	; 56
		if((data<<i)&0x80) DDRA &= ~0xDC;
		else DDRA |= 0xDC;
		i2c_wait();
		DDRA &= ~(1<<PA1);
		i2c_wait();
		DDRA |= (1<<PA1);
 11c:	d1 9a       	sbi	0x1a, 1	; 26
 11e:	2f 5f       	subi	r18, 0xFF	; 255
 120:	3f 4f       	sbci	r19, 0xFF	; 255
	i2c_wait();
	DDRA |= (1<<PA1);
}

static void sensor_write(uint8_t data) { //TODO: optimize...
	for(uint8_t i = 0; i < 8; i++) {
 122:	28 30       	cpi	r18, 0x08	; 8
 124:	31 05       	cpc	r19, r1
 126:	e9 f6       	brne	.-70     	; 0xe2 <__stack+0x3>
		i2c_wait();
		DDRA &= ~(1<<PA1);
		i2c_wait();
		DDRA |= (1<<PA1);
	}
	DDRA &= ~0xDC;
 128:	8a b3       	in	r24, 0x1a	; 26
 12a:	83 72       	andi	r24, 0x23	; 35
 12c:	8a bb       	out	0x1a, r24	; 26
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
 12e:	08 b6       	in	r0, 0x38	; 56
 130:	04 fe       	sbrs	r0, 4
 132:	fd cf       	rjmp	.-6      	; 0x12e <__stack+0x4f>
	TIFR |= (1<<OCF0A);
 134:	88 b7       	in	r24, 0x38	; 56
 136:	80 61       	ori	r24, 0x10	; 16
 138:	88 bf       	out	0x38, r24	; 56
		i2c_wait();
		DDRA |= (1<<PA1);
	}
	DDRA &= ~0xDC;
	i2c_wait();
	DDRA &= ~(1<<PA1);
 13a:	d1 98       	cbi	0x1a, 1	; 26
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
 13c:	08 b6       	in	r0, 0x38	; 56
 13e:	04 fe       	sbrs	r0, 4
 140:	fd cf       	rjmp	.-6      	; 0x13c <__stack+0x5d>
	TIFR |= (1<<OCF0A);
 142:	88 b7       	in	r24, 0x38	; 56
 144:	80 61       	ori	r24, 0x10	; 16
 146:	88 bf       	out	0x38, r24	; 56
	}
	DDRA &= ~0xDC;
	i2c_wait();
	DDRA &= ~(1<<PA1);
	i2c_wait();
	DDRA |= (1<<PA1);
 148:	d1 9a       	sbi	0x1a, 1	; 26
 14a:	08 95       	ret

0000014c <sensor_read>:
}

static uint8_t sensor_read(uint8_t ack) { //TODO: optimize...
 14c:	cf 92       	push	r12
 14e:	df 92       	push	r13
 150:	ef 92       	push	r14
 152:	ff 92       	push	r15
 154:	0f 93       	push	r16
 156:	1f 93       	push	r17
 158:	cf 93       	push	r28
 15a:	df 93       	push	r29
	DDRA &= ~0xDC;
 15c:	9a b3       	in	r25, 0x1a	; 26
 15e:	93 72       	andi	r25, 0x23	; 35
 160:	9a bb       	out	0x1a, r25	; 26
	uint8_t read = 0;
	usiTwiTxBuf[0+ack] = 0;
 162:	48 2f       	mov	r20, r24
 164:	50 e0       	ldi	r21, 0x00	; 0
 166:	fa 01       	movw	r30, r20
 168:	e8 59       	subi	r30, 0x98	; 152
 16a:	ff 4f       	sbci	r31, 0xFF	; 255
 16c:	10 82       	st	Z, r1
	usiTwiTxBuf[1+ack] = 0;
 16e:	ba 01       	movw	r22, r20
 170:	6f 5f       	subi	r22, 0xFF	; 255
 172:	7f 4f       	sbci	r23, 0xFF	; 255
 174:	fb 01       	movw	r30, r22
 176:	e8 59       	subi	r30, 0x98	; 152
 178:	ff 4f       	sbci	r31, 0xFF	; 255
 17a:	10 82       	st	Z, r1
	usiTwiTxBuf[2+ack] = 0;
 17c:	ea 01       	movw	r28, r20
 17e:	22 96       	adiw	r28, 0x02	; 2
 180:	fe 01       	movw	r30, r28
 182:	e8 59       	subi	r30, 0x98	; 152
 184:	ff 4f       	sbci	r31, 0xFF	; 255
 186:	10 82       	st	Z, r1
	usiTwiTxBuf[3+ack] = 0;
 188:	da 01       	movw	r26, r20
 18a:	13 96       	adiw	r26, 0x03	; 3
 18c:	fd 01       	movw	r30, r26
 18e:	e8 59       	subi	r30, 0x98	; 152
 190:	ff 4f       	sbci	r31, 0xFF	; 255
 192:	10 82       	st	Z, r1
	usiTwiTxBuf[4+ack] = 0;
 194:	8a 01       	movw	r16, r20
 196:	0c 5f       	subi	r16, 0xFC	; 252
 198:	1f 4f       	sbci	r17, 0xFF	; 255
 19a:	98 01       	movw	r18, r16
 19c:	28 59       	subi	r18, 0x98	; 152
 19e:	3f 4f       	sbci	r19, 0xFF	; 255
 1a0:	f9 01       	movw	r30, r18
 1a2:	10 82       	st	Z, r1
 1a4:	20 e0       	ldi	r18, 0x00	; 0
 1a6:	30 e0       	ldi	r19, 0x00	; 0
	for(uint8_t i = 0; i < 8; i++) {
		i2c_wait();
		DDRA &= ~(1<<PA1);
		if(PINA&(1<<PA7)) usiTwiTxBuf[0+ack] |= (0x80>>i);
 1a8:	fa 01       	movw	r30, r20
 1aa:	e8 59       	subi	r30, 0x98	; 152
 1ac:	ff 4f       	sbci	r31, 0xFF	; 255
 1ae:	7f 01       	movw	r14, r30
 1b0:	40 e8       	ldi	r20, 0x80	; 128
 1b2:	50 e0       	ldi	r21, 0x00	; 0
		if(PINA&(1<<PA2)) usiTwiTxBuf[1+ack] |= (0x80>>i);
 1b4:	68 59       	subi	r22, 0x98	; 152
 1b6:	7f 4f       	sbci	r23, 0xFF	; 255
		if(PINA&(1<<PA3)) usiTwiTxBuf[2+ack] |= (0x80>>i);
 1b8:	c8 59       	subi	r28, 0x98	; 152
 1ba:	df 4f       	sbci	r29, 0xFF	; 255
		if(PINA&(1<<PA4)) usiTwiTxBuf[3+ack] |= (0x80>>i);
 1bc:	a8 59       	subi	r26, 0x98	; 152
 1be:	bf 4f       	sbci	r27, 0xFF	; 255
		if(PINA&(1<<PA6)) usiTwiTxBuf[4+ack] |= (0x80>>i);
 1c0:	f8 01       	movw	r30, r16
 1c2:	e8 59       	subi	r30, 0x98	; 152
 1c4:	ff 4f       	sbci	r31, 0xFF	; 255
 1c6:	6f 01       	movw	r12, r30
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
 1c8:	08 b6       	in	r0, 0x38	; 56
 1ca:	04 fe       	sbrs	r0, 4
 1cc:	fd cf       	rjmp	.-6      	; 0x1c8 <sensor_read+0x7c>
	TIFR |= (1<<OCF0A);
 1ce:	98 b7       	in	r25, 0x38	; 56
 1d0:	90 61       	ori	r25, 0x10	; 16
 1d2:	98 bf       	out	0x38, r25	; 56
	usiTwiTxBuf[2+ack] = 0;
	usiTwiTxBuf[3+ack] = 0;
	usiTwiTxBuf[4+ack] = 0;
	for(uint8_t i = 0; i < 8; i++) {
		i2c_wait();
		DDRA &= ~(1<<PA1);
 1d4:	d1 98       	cbi	0x1a, 1	; 26
		if(PINA&(1<<PA7)) usiTwiTxBuf[0+ack] |= (0x80>>i);
 1d6:	cf 9b       	sbis	0x19, 7	; 25
 1d8:	0b c0       	rjmp	.+22     	; 0x1f0 <sensor_read+0xa4>
 1da:	f7 01       	movw	r30, r14
 1dc:	90 81       	ld	r25, Z
 1de:	8a 01       	movw	r16, r20
 1e0:	02 2e       	mov	r0, r18
 1e2:	02 c0       	rjmp	.+4      	; 0x1e8 <sensor_read+0x9c>
 1e4:	15 95       	asr	r17
 1e6:	07 95       	ror	r16
 1e8:	0a 94       	dec	r0
 1ea:	e2 f7       	brpl	.-8      	; 0x1e4 <sensor_read+0x98>
 1ec:	09 2b       	or	r16, r25
 1ee:	00 83       	st	Z, r16
		if(PINA&(1<<PA2)) usiTwiTxBuf[1+ack] |= (0x80>>i);
 1f0:	ca 9b       	sbis	0x19, 2	; 25
 1f2:	0b c0       	rjmp	.+22     	; 0x20a <sensor_read+0xbe>
 1f4:	fb 01       	movw	r30, r22
 1f6:	90 81       	ld	r25, Z
 1f8:	8a 01       	movw	r16, r20
 1fa:	02 2e       	mov	r0, r18
 1fc:	02 c0       	rjmp	.+4      	; 0x202 <sensor_read+0xb6>
 1fe:	15 95       	asr	r17
 200:	07 95       	ror	r16
 202:	0a 94       	dec	r0
 204:	e2 f7       	brpl	.-8      	; 0x1fe <sensor_read+0xb2>
 206:	09 2b       	or	r16, r25
 208:	00 83       	st	Z, r16
		if(PINA&(1<<PA3)) usiTwiTxBuf[2+ack] |= (0x80>>i);
 20a:	cb 9b       	sbis	0x19, 3	; 25
 20c:	0a c0       	rjmp	.+20     	; 0x222 <sensor_read+0xd6>
 20e:	98 81       	ld	r25, Y
 210:	8a 01       	movw	r16, r20
 212:	02 2e       	mov	r0, r18
 214:	02 c0       	rjmp	.+4      	; 0x21a <sensor_read+0xce>
 216:	15 95       	asr	r17
 218:	07 95       	ror	r16
 21a:	0a 94       	dec	r0
 21c:	e2 f7       	brpl	.-8      	; 0x216 <sensor_read+0xca>
 21e:	09 2b       	or	r16, r25
 220:	08 83       	st	Y, r16
		if(PINA&(1<<PA4)) usiTwiTxBuf[3+ack] |= (0x80>>i);
 222:	cc 9b       	sbis	0x19, 4	; 25
 224:	0a c0       	rjmp	.+20     	; 0x23a <sensor_read+0xee>
 226:	9c 91       	ld	r25, X
 228:	8a 01       	movw	r16, r20
 22a:	02 2e       	mov	r0, r18
 22c:	02 c0       	rjmp	.+4      	; 0x232 <sensor_read+0xe6>
 22e:	15 95       	asr	r17
 230:	07 95       	ror	r16
 232:	0a 94       	dec	r0
 234:	e2 f7       	brpl	.-8      	; 0x22e <sensor_read+0xe2>
 236:	09 2b       	or	r16, r25
 238:	0c 93       	st	X, r16
		if(PINA&(1<<PA6)) usiTwiTxBuf[4+ack] |= (0x80>>i);
 23a:	ce 9b       	sbis	0x19, 6	; 25
 23c:	0b c0       	rjmp	.+22     	; 0x254 <sensor_read+0x108>
 23e:	f6 01       	movw	r30, r12
 240:	90 81       	ld	r25, Z
 242:	8a 01       	movw	r16, r20
 244:	02 2e       	mov	r0, r18
 246:	02 c0       	rjmp	.+4      	; 0x24c <sensor_read+0x100>
 248:	15 95       	asr	r17
 24a:	07 95       	ror	r16
 24c:	0a 94       	dec	r0
 24e:	e2 f7       	brpl	.-8      	; 0x248 <sensor_read+0xfc>
 250:	09 2b       	or	r16, r25
 252:	00 83       	st	Z, r16
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
 254:	08 b6       	in	r0, 0x38	; 56
 256:	04 fe       	sbrs	r0, 4
 258:	fd cf       	rjmp	.-6      	; 0x254 <sensor_read+0x108>
	TIFR |= (1<<OCF0A);
 25a:	98 b7       	in	r25, 0x38	; 56
 25c:	90 61       	ori	r25, 0x10	; 16
 25e:	98 bf       	out	0x38, r25	; 56
		if(PINA&(1<<PA2)) usiTwiTxBuf[1+ack] |= (0x80>>i);
		if(PINA&(1<<PA3)) usiTwiTxBuf[2+ack] |= (0x80>>i);
		if(PINA&(1<<PA4)) usiTwiTxBuf[3+ack] |= (0x80>>i);
		if(PINA&(1<<PA6)) usiTwiTxBuf[4+ack] |= (0x80>>i);
		i2c_wait();
		DDRA |= (1<<PA1);
 260:	d1 9a       	sbi	0x1a, 1	; 26
 262:	2f 5f       	subi	r18, 0xFF	; 255
 264:	3f 4f       	sbci	r19, 0xFF	; 255
	usiTwiTxBuf[0+ack] = 0;
	usiTwiTxBuf[1+ack] = 0;
	usiTwiTxBuf[2+ack] = 0;
	usiTwiTxBuf[3+ack] = 0;
	usiTwiTxBuf[4+ack] = 0;
	for(uint8_t i = 0; i < 8; i++) {
 266:	28 30       	cpi	r18, 0x08	; 8
 268:	31 05       	cpc	r19, r1
 26a:	09 f0       	breq	.+2      	; 0x26e <sensor_read+0x122>
 26c:	ad cf       	rjmp	.-166    	; 0x1c8 <sensor_read+0x7c>
		if(PINA&(1<<PA4)) usiTwiTxBuf[3+ack] |= (0x80>>i);
		if(PINA&(1<<PA6)) usiTwiTxBuf[4+ack] |= (0x80>>i);
		i2c_wait();
		DDRA |= (1<<PA1);
	}
	if(!ack)DDRA |= 0xDC;
 26e:	81 11       	cpse	r24, r1
 270:	03 c0       	rjmp	.+6      	; 0x278 <sensor_read+0x12c>
 272:	8a b3       	in	r24, 0x1a	; 26
 274:	8c 6d       	ori	r24, 0xDC	; 220
 276:	8a bb       	out	0x1a, r24	; 26
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
 278:	08 b6       	in	r0, 0x38	; 56
 27a:	04 fe       	sbrs	r0, 4
 27c:	fd cf       	rjmp	.-6      	; 0x278 <sensor_read+0x12c>
	TIFR |= (1<<OCF0A);
 27e:	88 b7       	in	r24, 0x38	; 56
 280:	80 61       	ori	r24, 0x10	; 16
 282:	88 bf       	out	0x38, r24	; 56
		i2c_wait();
		DDRA |= (1<<PA1);
	}
	if(!ack)DDRA |= 0xDC;
	i2c_wait();
	DDRA &= ~(1<<PA1);
 284:	d1 98       	cbi	0x1a, 1	; 26
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
 286:	08 b6       	in	r0, 0x38	; 56
 288:	04 fe       	sbrs	r0, 4
 28a:	fd cf       	rjmp	.-6      	; 0x286 <sensor_read+0x13a>
	TIFR |= (1<<OCF0A);
 28c:	88 b7       	in	r24, 0x38	; 56
 28e:	80 61       	ori	r24, 0x10	; 16
 290:	88 bf       	out	0x38, r24	; 56
	}
	if(!ack)DDRA |= 0xDC;
	i2c_wait();
	DDRA &= ~(1<<PA1);
	i2c_wait();
	DDRA |= (1<<PA1);
 292:	d1 9a       	sbi	0x1a, 1	; 26
	DDRA &= ~0xDC;
 294:	8a b3       	in	r24, 0x1a	; 26
 296:	83 72       	andi	r24, 0x23	; 35
 298:	8a bb       	out	0x1a, r24	; 26
	
	return read;
}
 29a:	80 e0       	ldi	r24, 0x00	; 0
 29c:	df 91       	pop	r29
 29e:	cf 91       	pop	r28
 2a0:	1f 91       	pop	r17
 2a2:	0f 91       	pop	r16
 2a4:	ff 90       	pop	r15
 2a6:	ef 90       	pop	r14
 2a8:	df 90       	pop	r13
 2aa:	cf 90       	pop	r12
 2ac:	08 95       	ret

000002ae <sensor_stop>:

static void sensor_stop() {
	DDRA |= 0xDC;
 2ae:	8a b3       	in	r24, 0x1a	; 26
 2b0:	8c 6d       	ori	r24, 0xDC	; 220
 2b2:	8a bb       	out	0x1a, r24	; 26
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
 2b4:	08 b6       	in	r0, 0x38	; 56
 2b6:	04 fe       	sbrs	r0, 4
 2b8:	fd cf       	rjmp	.-6      	; 0x2b4 <sensor_stop+0x6>
	TIFR |= (1<<OCF0A);
 2ba:	88 b7       	in	r24, 0x38	; 56
 2bc:	80 61       	ori	r24, 0x10	; 16
 2be:	88 bf       	out	0x38, r24	; 56
}

static void sensor_stop() {
	DDRA |= 0xDC;
	i2c_wait();
	DDRA &= ~(1<<PA1);
 2c0:	d1 98       	cbi	0x1a, 1	; 26
#include <util/delay.h>
#include <avr/interrupt.h>
#include "usiTwiSlave.h"

static inline void i2c_wait(void) {
	while(!(TIFR & (1<<OCF0A)));
 2c2:	08 b6       	in	r0, 0x38	; 56
 2c4:	04 fe       	sbrs	r0, 4
 2c6:	fd cf       	rjmp	.-6      	; 0x2c2 <sensor_stop+0x14>
	TIFR |= (1<<OCF0A);
 2c8:	88 b7       	in	r24, 0x38	; 56
 2ca:	80 61       	ori	r24, 0x10	; 16
 2cc:	88 bf       	out	0x38, r24	; 56
static void sensor_stop() {
	DDRA |= 0xDC;
	i2c_wait();
	DDRA &= ~(1<<PA1);
	i2c_wait();
	DDRA &= ~0xDC;
 2ce:	8a b3       	in	r24, 0x1a	; 26
 2d0:	83 72       	andi	r24, 0x23	; 35
 2d2:	8a bb       	out	0x1a, r24	; 26
 2d4:	08 95       	ret

000002d6 <cbread>:
		usiTwiTxBuf[0] = 1;
		usiTwiTxBuf[1] = 10;
		return 2;
	}*/
	return 0;
}
 2d6:	80 e0       	ldi	r24, 0x00	; 0
 2d8:	08 95       	ret

000002da <cbwrite>:
/*
	memcpy(vals, usiTwiTxBuf, sizeof(vals));
	return sizeof(vals);
*/
	return 10;
}
 2da:	8a e0       	ldi	r24, 0x0A	; 10
 2dc:	08 95       	ret

000002de <main>:

int main(void) {
	
	OCR0A = 20;
 2de:	84 e1       	ldi	r24, 0x14	; 20
 2e0:	83 bb       	out	0x13, r24	; 19
	TCCR0A = (1<<0);
 2e2:	81 e0       	ldi	r24, 0x01	; 1
 2e4:	85 bb       	out	0x15, r24	; 21
	TCCR0B = (1<<CS00);
 2e6:	83 bf       	out	0x33, r24	; 51
	
	OCR1B = 0;
 2e8:	1c bc       	out	0x2c, r1	; 44
	OCR1D = 255;
 2ea:	9f ef       	ldi	r25, 0xFF	; 255
 2ec:	9a bd       	out	0x2a, r25	; 42
	OCR1C = 255;
 2ee:	9b bd       	out	0x2b, r25	; 43
	TCCR1A = (1<<PWM1B);
 2f0:	80 bf       	out	0x30, r24	; 48
	TCCR1B = (1<<CS10);
 2f2:	8f bd       	out	0x2f, r24	; 47
	TCCR1C = (1<<COM1B0S) | (1<<COM1D1) | (1<<COM1D0) | (1<<PWM1D);
 2f4:	8d e1       	ldi	r24, 0x1D	; 29
 2f6:	87 bd       	out	0x27, r24	; 39
	DDRB = (1<<PB3) | (1<<PB5);
 2f8:	88 e2       	ldi	r24, 0x28	; 40
 2fa:	87 bb       	out	0x17, r24	; 23
	
	usiTwiSlaveCB(cbread, cbwrite);
 2fc:	6d e6       	ldi	r22, 0x6D	; 109
 2fe:	71 e0       	ldi	r23, 0x01	; 1
 300:	8b e6       	ldi	r24, 0x6B	; 107
 302:	91 e0       	ldi	r25, 0x01	; 1
 304:	34 d0       	rcall	.+104    	; 0x36e <usiTwiSlaveCB>
	usiTwiSlaveInit();
 306:	3c d0       	rcall	.+120    	; 0x380 <usiTwiSlaveInit>
	sei();
 308:	78 94       	sei
	
	sensor_start(0);
 30a:	80 e0       	ldi	r24, 0x00	; 0
 30c:	9b de       	rcall	.-714    	; 0x44 <sensor_start>
	sensor_write(0x80);
 30e:	80 e8       	ldi	r24, 0x80	; 128
 310:	e4 de       	rcall	.-568    	; 0xda <sensor_write>
	sensor_write(0x01);
 312:	81 e0       	ldi	r24, 0x01	; 1
 314:	e2 de       	rcall	.-572    	; 0xda <sensor_write>
	sensor_stop();
 316:	cb df       	rcall	.-106    	; 0x2ae <sensor_stop>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 318:	8f e1       	ldi	r24, 0x1F	; 31
 31a:	9e e4       	ldi	r25, 0x4E	; 78
 31c:	01 97       	sbiw	r24, 0x01	; 1
 31e:	f1 f7       	brne	.-4      	; 0x31c <main+0x3e>
 320:	00 c0       	rjmp	.+0      	; 0x322 <main+0x44>
 322:	00 00       	nop
	_delay_ms(10);
	sensor_start(0);
 324:	80 e0       	ldi	r24, 0x00	; 0
 326:	8e de       	rcall	.-740    	; 0x44 <sensor_start>
	sensor_write(0x80);
 328:	80 e8       	ldi	r24, 0x80	; 128
 32a:	d7 de       	rcall	.-594    	; 0xda <sensor_write>
	sensor_write(0x03);
 32c:	83 e0       	ldi	r24, 0x03	; 3
 32e:	d5 de       	rcall	.-598    	; 0xda <sensor_write>
	sensor_stop();
 330:	be df       	rcall	.-132    	; 0x2ae <sensor_stop>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 332:	9d e0       	ldi	r25, 0x0D	; 13
 334:	9a 95       	dec	r25
 336:	f1 f7       	brne	.-4      	; 0x334 <main+0x56>
 338:	00 00       	nop
	_delay_us(5);
	
	while(1) {
		sensor_start(0);
 33a:	80 e0       	ldi	r24, 0x00	; 0
 33c:	83 de       	rcall	.-762    	; 0x44 <sensor_start>
		sensor_write(0xB4);
 33e:	84 eb       	ldi	r24, 0xB4	; 180
 340:	cc de       	rcall	.-616    	; 0xda <sensor_write>
		sensor_stop();
 342:	b5 df       	rcall	.-150    	; 0x2ae <sensor_stop>
 344:	2d e0       	ldi	r18, 0x0D	; 13
 346:	2a 95       	dec	r18
 348:	f1 f7       	brne	.-4      	; 0x346 <main+0x68>
 34a:	00 00       	nop
		_delay_us(5);
		sensor_start(1);
 34c:	81 e0       	ldi	r24, 0x01	; 1
 34e:	7a de       	rcall	.-780    	; 0x44 <sensor_start>
		sensor_read(0);
 350:	80 e0       	ldi	r24, 0x00	; 0
 352:	fc de       	rcall	.-520    	; 0x14c <sensor_read>
		sensor_read(5);
 354:	85 e0       	ldi	r24, 0x05	; 5
 356:	fa de       	rcall	.-524    	; 0x14c <sensor_read>
		sensor_stop();
 358:	aa df       	rcall	.-172    	; 0x2ae <sensor_stop>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 35a:	8f ef       	ldi	r24, 0xFF	; 255
 35c:	90 e7       	ldi	r25, 0x70	; 112
 35e:	22 e0       	ldi	r18, 0x02	; 2
 360:	81 50       	subi	r24, 0x01	; 1
 362:	90 40       	sbci	r25, 0x00	; 0
 364:	20 40       	sbci	r18, 0x00	; 0
 366:	e1 f7       	brne	.-8      	; 0x360 <main+0x82>
 368:	00 c0       	rjmp	.+0      	; 0x36a <main+0x8c>
 36a:	00 00       	nop
 36c:	e6 cf       	rjmp	.-52     	; 0x33a <main+0x5c>

0000036e <usiTwiSlaveCB>:
 * The buffers may only be accessed from within the call back funktions
 * The callback functions are called from within the interrupt context.
 *
 */
void usiTwiSlaveCB( uint8_t (*cbRecieve) (uint8_t len), uint8_t (*cbTransmit) (void)){
	cbTx = cbTransmit;
 36e:	70 93 63 00 	sts	0x0063, r23
 372:	60 93 62 00 	sts	0x0062, r22
	cbRx = cbRecieve;
 376:	90 93 61 00 	sts	0x0061, r25
 37a:	80 93 60 00 	sts	0x0060, r24
 37e:	08 95       	ret

00000380 <usiTwiSlaveInit>:
	// low when a start condition is detected or a counter overflow (only
	// for USIWM1, USIWM0 = 11).  This inserts a wait state.  SCL is released
	// by the ISRs (USI_START_vect and USI_OVERFLOW_vect).

	// Set SCL and SDA as output
	DDRB |= (1 << PB2) | (1 << PB0);
 380:	87 b3       	in	r24, 0x17	; 23
 382:	85 60       	ori	r24, 0x05	; 5
 384:	87 bb       	out	0x17, r24	; 23

	// set SCL high
	PORTB |= (1 << PB2);
 386:	c2 9a       	sbi	0x18, 2	; 24

	// set SDA high
	PORTB |= (1 << PB0);
 388:	c0 9a       	sbi	0x18, 0	; 24

	// Set SDA as input
	DDRB &= ~(1 << PB0);
 38a:	b8 98       	cbi	0x17, 0	; 23

	USICR =
 38c:	88 ea       	ldi	r24, 0xA8	; 168
 38e:	8d b9       	out	0x0d, r24	; 13
					// no toggle clock-port pin
					(0 << USITC);

	// clear all interrupt flags and reset overflow counter

	USISR = (1 << USISIF) | (1 << USIOIF) | (1 << USIPF)
 390:	80 ef       	ldi	r24, 0xF0	; 240
 392:	8e b9       	out	0x0e, r24	; 14
 394:	08 95       	ret

00000396 <__vector_7>:

 USI Start Condition ISR

 ********************************************************************************/

ISR( USI_START_vect ) {
 396:	1f 92       	push	r1
 398:	0f 92       	push	r0
 39a:	0f b6       	in	r0, 0x3f	; 63
 39c:	0f 92       	push	r0
 39e:	11 24       	eor	r1, r1
 3a0:	2f 93       	push	r18
 3a2:	3f 93       	push	r19
 3a4:	4f 93       	push	r20
 3a6:	5f 93       	push	r21
 3a8:	6f 93       	push	r22
 3aa:	7f 93       	push	r23
 3ac:	8f 93       	push	r24
 3ae:	9f 93       	push	r25
 3b0:	af 93       	push	r26
 3b2:	bf 93       	push	r27
 3b4:	ef 93       	push	r30
 3b6:	ff 93       	push	r31

	// set default starting conditions for new TWI package
	overflowState = USI_SLAVE_CHECK_ADDRESS;
 3b8:	10 92 67 00 	sts	0x0067, r1

	// set SDA as input
	DDRB &= ~(1 << PB0);
 3bc:	b8 98       	cbi	0x17, 0	; 23
	cbRx = cbRecieve;
}


static void callRx (void){
	if(cbRx && usiTwiRxPos ){
 3be:	e0 91 60 00 	lds	r30, 0x0060
 3c2:	f0 91 61 00 	lds	r31, 0x0061
 3c6:	30 97       	sbiw	r30, 0x00	; 0
 3c8:	39 f0       	breq	.+14     	; 0x3d8 <__vector_7+0x42>
 3ca:	80 91 66 00 	lds	r24, 0x0066
 3ce:	88 23       	and	r24, r24
 3d0:	19 f0       	breq	.+6      	; 0x3d8 <__vector_7+0x42>
		usiTwiTxSize = cbRx(usiTwiRxPos);
 3d2:	09 95       	icall
 3d4:	80 93 64 00 	sts	0x0064, r24
	}
	usiTwiRxPos = 0;
 3d8:	10 92 66 00 	sts	0x0066, r1
	// wait for SCL to go low to ensure the Start Condition has completed (the
	// start detector will hold SCL low ) - if a Stop Condition arises then leave
	// the interrupt to prevent waiting forever - don't use USISR to test for Stop
	// Condition as in Application Note AVR312 because the Stop Condition Flag is
	// going to be set from the last TWI sequence
	while (
 3dc:	b2 9b       	sbis	0x16, 2	; 22
 3de:	02 c0       	rjmp	.+4      	; 0x3e4 <__vector_7+0x4e>
	// SCL his high
	( PINB & (1 << PB2)) &&
 3e0:	b0 9b       	sbis	0x16, 0	; 22
 3e2:	fc cf       	rjmp	.-8      	; 0x3dc <__vector_7+0x46>
	// and SDA is low
			!(( PINB & (1 << PB0))))
		;

	if (!( PINB & (1 << PB0))) {
 3e4:	b0 99       	sbic	0x16, 0	; 22
 3e6:	03 c0       	rjmp	.+6      	; 0x3ee <__vector_7+0x58>

		// a Stop Condition did not occur

		USICR =
 3e8:	88 ef       	ldi	r24, 0xF8	; 248
 3ea:	8d b9       	out	0x0d, r24	; 13
 3ec:	04 c0       	rjmp	.+8      	; 0x3f6 <__vector_7+0x60>
						// no toggle clock-port pin
						(0 << USITC);

	} else {
		// a Stop Condition did occur
		usiTwiTxPos = 0;
 3ee:	10 92 65 00 	sts	0x0065, r1
		USICR =
 3f2:	88 ea       	ldi	r24, 0xA8	; 168
 3f4:	8d b9       	out	0x0d, r24	; 13
						// no toggle clock-port pin
						(0 << USITC);

	} // end if

	USISR =
 3f6:	80 ef       	ldi	r24, 0xF0	; 240
 3f8:	8e b9       	out	0x0e, r24	; 14
			(1 << USISIF) | (1 << USIOIF) | (1 << USIPF)
					| (1 << USIDC) |
					// set USI to sample 8 bits (count 16 external SCL pin toggles)
					(0x0 << USICNT0);

} // end ISR( USI_START_vect )
 3fa:	ff 91       	pop	r31
 3fc:	ef 91       	pop	r30
 3fe:	bf 91       	pop	r27
 400:	af 91       	pop	r26
 402:	9f 91       	pop	r25
 404:	8f 91       	pop	r24
 406:	7f 91       	pop	r23
 408:	6f 91       	pop	r22
 40a:	5f 91       	pop	r21
 40c:	4f 91       	pop	r20
 40e:	3f 91       	pop	r19
 410:	2f 91       	pop	r18
 412:	0f 90       	pop	r0
 414:	0f be       	out	0x3f, r0	; 63
 416:	0f 90       	pop	r0
 418:	1f 90       	pop	r1
 41a:	18 95       	reti

0000041c <__vector_8>:

 Only disabled when waiting for a new Start Condition.

 ********************************************************************************/

ISR( USI_OVF_vect ) {
 41c:	1f 92       	push	r1
 41e:	0f 92       	push	r0
 420:	0f b6       	in	r0, 0x3f	; 63
 422:	0f 92       	push	r0
 424:	11 24       	eor	r1, r1
 426:	2f 93       	push	r18
 428:	3f 93       	push	r19
 42a:	4f 93       	push	r20
 42c:	5f 93       	push	r21
 42e:	6f 93       	push	r22
 430:	7f 93       	push	r23
 432:	8f 93       	push	r24
 434:	9f 93       	push	r25
 436:	af 93       	push	r26
 438:	bf 93       	push	r27
 43a:	ef 93       	push	r30
 43c:	ff 93       	push	r31

	switch (overflowState) {
 43e:	80 91 67 00 	lds	r24, 0x0067
 442:	82 30       	cpi	r24, 0x02	; 2
 444:	09 f4       	brne	.+2      	; 0x448 <__vector_8+0x2c>
 446:	59 c0       	rjmp	.+178    	; 0x4fa <__vector_8+0xde>
 448:	28 f4       	brcc	.+10     	; 0x454 <__vector_8+0x38>
 44a:	88 23       	and	r24, r24
 44c:	59 f0       	breq	.+22     	; 0x464 <__vector_8+0x48>
 44e:	81 30       	cpi	r24, 0x01	; 1
 450:	c1 f1       	breq	.+112    	; 0x4c2 <__vector_8+0xa6>
 452:	7b c0       	rjmp	.+246    	; 0x54a <__vector_8+0x12e>
 454:	84 30       	cpi	r24, 0x04	; 4
 456:	09 f4       	brne	.+2      	; 0x45a <__vector_8+0x3e>
 458:	58 c0       	rjmp	.+176    	; 0x50a <__vector_8+0xee>
 45a:	58 f1       	brcs	.+86     	; 0x4b2 <__vector_8+0x96>
 45c:	85 30       	cpi	r24, 0x05	; 5
 45e:	09 f4       	brne	.+2      	; 0x462 <__vector_8+0x46>
 460:	5b c0       	rjmp	.+182    	; 0x518 <__vector_8+0xfc>
 462:	73 c0       	rjmp	.+230    	; 0x54a <__vector_8+0x12e>

	// Address mode: check address and send ACK (and next USI_SLAVE_SEND_DATA) if OK,
	// else reset USI
	case USI_SLAVE_CHECK_ADDRESS:
		if ((USIDR == 0) || ((USIDR >> 1) == USI_ADDRESS)) {
 464:	8f b1       	in	r24, 0x0f	; 15
 466:	88 23       	and	r24, r24
 468:	21 f0       	breq	.+8      	; 0x472 <__vector_8+0x56>
 46a:	8f b1       	in	r24, 0x0f	; 15
 46c:	86 95       	lsr	r24
 46e:	88 31       	cpi	r24, 0x18	; 24
 470:	d9 f4       	brne	.+54     	; 0x4a8 <__vector_8+0x8c>
			if (USIDR & 0x01) {
 472:	78 9b       	sbis	0x0f, 0	; 15
 474:	11 c0       	rjmp	.+34     	; 0x498 <__vector_8+0x7c>
				overflowState = USI_SLAVE_SEND_DATA;
 476:	81 e0       	ldi	r24, 0x01	; 1
 478:	80 93 67 00 	sts	0x0067, r24
	usiTwiRxPos = 0;
}

static void callTx (void){
	//Call Tx if nothing has been written by the Rx handler
	if(!usiTwiTxSize){
 47c:	80 91 64 00 	lds	r24, 0x0064
 480:	81 11       	cpse	r24, r1
 482:	07 c0       	rjmp	.+14     	; 0x492 <__vector_8+0x76>
		usiTwiTxSize = cbTx();
 484:	e0 91 62 00 	lds	r30, 0x0062
 488:	f0 91 63 00 	lds	r31, 0x0063
 48c:	09 95       	icall
 48e:	80 93 64 00 	sts	0x0064, r24
	}
	usiTwiTxPos = 0;
 492:	10 92 65 00 	sts	0x0065, r1
 496:	03 c0       	rjmp	.+6      	; 0x49e <__vector_8+0x82>
		if ((USIDR == 0) || ((USIDR >> 1) == USI_ADDRESS)) {
			if (USIDR & 0x01) {
				overflowState = USI_SLAVE_SEND_DATA;
				callTx();
			} else {
				overflowState = USI_SLAVE_REQUEST_DATA;
 498:	84 e0       	ldi	r24, 0x04	; 4
 49a:	80 93 67 00 	sts	0x0067, r24

 ********************************************************************************/

static inline void SET_USI_TO_SEND_ACK() {
	/* prepare ACK */
	USIDR = 0;
 49e:	1f b8       	out	0x0f, r1	; 15
	/* set SDA as output */
	DDRB |= (1 << PB0);
 4a0:	b8 9a       	sbi	0x17, 0	; 23
	/* clear all interrupt flags, except Start Cond */
	USISR = (0 << USISIF) | (1 << USIOIF) | (1 << USIPF)
 4a2:	8e e7       	ldi	r24, 0x7E	; 126
 4a4:	8e b9       	out	0x0e, r24	; 14
 4a6:	51 c0       	rjmp	.+162    	; 0x54a <__vector_8+0x12e>
			/* set USI counter to shift 1 bit */
			(0x0E << USICNT0);
}

static inline void SET_USI_TO_TWI_START_CONDITION_MODE() {
	USICR =
 4a8:	88 ea       	ldi	r24, 0xA8	; 168
 4aa:	8d b9       	out	0x0d, r24	; 13
	/* Shift Register Clock Source = External, positive edge */
	/* 4-Bit Counter Source = external, both edges */
	(1 << USICS1) | (0 << USICS0) | (0 << USICLK) |
	/* no toggle clock-port pin */
	(0 << USITC);
	USISR =
 4ac:	80 e7       	ldi	r24, 0x70	; 112
 4ae:	8e b9       	out	0x0e, r24	; 14
 4b0:	4c c0       	rjmp	.+152    	; 0x54a <__vector_8+0x12e>
		break;

		// Master write data mode: check reply and goto USI_SLAVE_SEND_DATA if OK,
		// else reset USI
	case USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA:
		if (USIDR) {
 4b2:	8f b1       	in	r24, 0x0f	; 15
 4b4:	88 23       	and	r24, r24
 4b6:	29 f0       	breq	.+10     	; 0x4c2 <__vector_8+0xa6>
			/* set USI counter to shift 1 bit */
			(0x0E << USICNT0);
}

static inline void SET_USI_TO_TWI_START_CONDITION_MODE() {
	USICR =
 4b8:	88 ea       	ldi	r24, 0xA8	; 168
 4ba:	8d b9       	out	0x0d, r24	; 13
	/* Shift Register Clock Source = External, positive edge */
	/* 4-Bit Counter Source = external, both edges */
	(1 << USICS1) | (0 << USICS0) | (0 << USICLK) |
	/* no toggle clock-port pin */
	(0 << USITC);
	USISR =
 4bc:	80 e7       	ldi	r24, 0x70	; 112
 4be:	8e b9       	out	0x0e, r24	; 14
 4c0:	44 c0       	rjmp	.+136    	; 0x54a <__vector_8+0x12e>

		// copy data from buffer to USIDR and set USI to shift byte
		// next USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA
	case USI_SLAVE_SEND_DATA:
		// Get data from Buffer
		if (usiTwiTxPos < usiTwiTxSize) {
 4c2:	e0 91 65 00 	lds	r30, 0x0065
 4c6:	80 91 64 00 	lds	r24, 0x0064
 4ca:	e8 17       	cp	r30, r24
 4cc:	88 f4       	brcc	.+34     	; 0x4f0 <__vector_8+0xd4>
			USIDR = usiTwiTxBuf[usiTwiTxPos];
 4ce:	f0 e0       	ldi	r31, 0x00	; 0
 4d0:	e8 59       	subi	r30, 0x98	; 152
 4d2:	ff 4f       	sbci	r31, 0xFF	; 255
 4d4:	80 81       	ld	r24, Z
 4d6:	8f b9       	out	0x0f, r24	; 15
			usiTwiTxPos++;
 4d8:	80 91 65 00 	lds	r24, 0x0065
 4dc:	8f 5f       	subi	r24, 0xFF	; 255
 4de:	80 93 65 00 	sts	0x0065, r24
			// the buffer is empty
			// Send Nack
			SET_USI_TO_TWI_START_CONDITION_MODE();
			return;
		} // end if
		overflowState = USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA;
 4e2:	82 e0       	ldi	r24, 0x02	; 2
 4e4:	80 93 67 00 	sts	0x0067, r24
			| (0x0 << USICNT0);
}

static inline void SET_USI_TO_SEND_DATA() {
	/* set SDA as output */
	DDRB |= (1 << PB0);
 4e8:	b8 9a       	sbi	0x17, 0	; 23
	/* clear all interrupt flags, except Start Cond */
	USISR = (0 << USISIF) | (1 << USIOIF) | (1 << USIPF)
 4ea:	80 e7       	ldi	r24, 0x70	; 112
 4ec:	8e b9       	out	0x0e, r24	; 14
 4ee:	2d c0       	rjmp	.+90     	; 0x54a <__vector_8+0x12e>
			/* set USI counter to shift 1 bit */
			(0x0E << USICNT0);
}

static inline void SET_USI_TO_TWI_START_CONDITION_MODE() {
	USICR =
 4f0:	88 ea       	ldi	r24, 0xA8	; 168
 4f2:	8d b9       	out	0x0d, r24	; 13
	/* Shift Register Clock Source = External, positive edge */
	/* 4-Bit Counter Source = external, both edges */
	(1 << USICS1) | (0 << USICS0) | (0 << USICLK) |
	/* no toggle clock-port pin */
	(0 << USITC);
	USISR =
 4f4:	80 e7       	ldi	r24, 0x70	; 112
 4f6:	8e b9       	out	0x0e, r24	; 14
 4f8:	28 c0       	rjmp	.+80     	; 0x54a <__vector_8+0x12e>
		break;

		// set USI to sample reply from master
		// next USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA
	case USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA:
		overflowState = USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA;
 4fa:	83 e0       	ldi	r24, 0x03	; 3
 4fc:	80 93 67 00 	sts	0x0067, r24
			(0x0E << USICNT0);
}

static inline void SET_USI_TO_READ_ACK() {
	/* set SDA as input */
	DDRB &= ~(1 << PB0);
 500:	b8 98       	cbi	0x17, 0	; 23
	/* prepare ACK */
	USIDR = 0;
 502:	1f b8       	out	0x0f, r1	; 15
	/* clear all interrupt flags, except Start Cond */
	USISR = (0 << USISIF) | (1 << USIOIF) | (1 << USIPF)
 504:	8e e7       	ldi	r24, 0x7E	; 126
 506:	8e b9       	out	0x0e, r24	; 14
 508:	20 c0       	rjmp	.+64     	; 0x54a <__vector_8+0x12e>
		break;

		// Master read data mode: set USI to sample data from master, next
		// USI_SLAVE_GET_DATA_AND_SEND_ACK
	case USI_SLAVE_REQUEST_DATA:
		overflowState = USI_SLAVE_GET_DATA_AND_SEND_ACK;
 50a:	85 e0       	ldi	r24, 0x05	; 5
 50c:	80 93 67 00 	sts	0x0067, r24
			(0x0 << USICNT0);
}

static inline void SET_USI_TO_READ_DATA() {
	/* set SDA as input */
	DDRB &= ~(1 << PB0);
 510:	b8 98       	cbi	0x17, 0	; 23
	/* clear all interrupt flags, except Start Cond */
	USISR = (0 << USISIF) | (1 << USIOIF) | (1 << USIPF)
 512:	80 e7       	ldi	r24, 0x70	; 112
 514:	8e b9       	out	0x0e, r24	; 14
 516:	19 c0       	rjmp	.+50     	; 0x54a <__vector_8+0x12e>
		// copy data from USIDR and send ACK
		// next USI_SLAVE_REQUEST_DATA
	case USI_SLAVE_GET_DATA_AND_SEND_ACK:
		// put data into buffer
		// Not necessary, but prevents warnings
		usiTwiRxBuf[usiTwiRxPos] = USIDR;
 518:	80 91 66 00 	lds	r24, 0x0066
 51c:	9f b1       	in	r25, 0x0f	; 15
 51e:	e8 2f       	mov	r30, r24
 520:	f0 e0       	ldi	r31, 0x00	; 0
 522:	e8 58       	subi	r30, 0x88	; 136
 524:	ff 4f       	sbci	r31, 0xFF	; 255
 526:	90 83       	st	Z, r25
		usiTwiRxPos ++;
 528:	8f 5f       	subi	r24, 0xFF	; 255
 52a:	80 93 66 00 	sts	0x0066, r24
		if(usiTwiRxPos == TWI_RX_BUFFER_SIZE){
 52e:	81 30       	cpi	r24, 0x01	; 1
 530:	29 f4       	brne	.+10     	; 0x53c <__vector_8+0x120>
			/* set USI counter to shift 1 bit */
			(0x0E << USICNT0);
}

static inline void SET_USI_TO_TWI_START_CONDITION_MODE() {
	USICR =
 532:	88 ea       	ldi	r24, 0xA8	; 168
 534:	8d b9       	out	0x0d, r24	; 13
	/* Shift Register Clock Source = External, positive edge */
	/* 4-Bit Counter Source = external, both edges */
	(1 << USICS1) | (0 << USICS0) | (0 << USICLK) |
	/* no toggle clock-port pin */
	(0 << USITC);
	USISR =
 536:	80 e7       	ldi	r24, 0x70	; 112
 538:	8e b9       	out	0x0e, r24	; 14
 53a:	07 c0       	rjmp	.+14     	; 0x54a <__vector_8+0x12e>
			// Send Nack
			SET_USI_TO_TWI_START_CONDITION_MODE();
			return;
		}
		// next USI_SLAVE_REQUEST_DATA
		overflowState = USI_SLAVE_REQUEST_DATA;
 53c:	84 e0       	ldi	r24, 0x04	; 4
 53e:	80 93 67 00 	sts	0x0067, r24

 ********************************************************************************/

static inline void SET_USI_TO_SEND_ACK() {
	/* prepare ACK */
	USIDR = 0;
 542:	1f b8       	out	0x0f, r1	; 15
	/* set SDA as output */
	DDRB |= (1 << PB0);
 544:	b8 9a       	sbi	0x17, 0	; 23
	/* clear all interrupt flags, except Start Cond */
	USISR = (0 << USISIF) | (1 << USIOIF) | (1 << USIPF)
 546:	8e e7       	ldi	r24, 0x7E	; 126
 548:	8e b9       	out	0x0e, r24	; 14
		SET_USI_TO_SEND_ACK();
		break;

	} // end switch

} // end ISR( USI_OVF_vect )
 54a:	ff 91       	pop	r31
 54c:	ef 91       	pop	r30
 54e:	bf 91       	pop	r27
 550:	af 91       	pop	r26
 552:	9f 91       	pop	r25
 554:	8f 91       	pop	r24
 556:	7f 91       	pop	r23
 558:	6f 91       	pop	r22
 55a:	5f 91       	pop	r21
 55c:	4f 91       	pop	r20
 55e:	3f 91       	pop	r19
 560:	2f 91       	pop	r18
 562:	0f 90       	pop	r0
 564:	0f be       	out	0x3f, r0	; 63
 566:	0f 90       	pop	r0
 568:	1f 90       	pop	r1
 56a:	18 95       	reti

0000056c <_exit>:
 56c:	f8 94       	cli

0000056e <__stop_program>:
 56e:	ff cf       	rjmp	.-2      	; 0x56e <__stop_program>
